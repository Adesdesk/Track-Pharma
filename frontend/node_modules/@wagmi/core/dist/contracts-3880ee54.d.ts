import { AbiParameter as AbiParameter$1, Abi, AbiFunction, AbiParametersToPrimitiveTypes, ExtractAbiFunction, Narrow, AbiStateMutability, ExtractAbiFunctionNames, AbiEvent, AbiParameterToPrimitiveType, Address, ResolvedConfig } from 'abitype';
import { ethers } from 'ethers';

/**
 * Count occurrences of {@link TType} in {@link TArray}
 *
 * @param TArray - Array to count occurrences in
 * @param TType - Type to count occurrences of
 * @returns Number of occurrences of {@link TType} in {@link TArray}
 *
 * @example
 * type Result = CountOccurrences<['foo', 'bar', 'foo'], 'foo'>
 */
type CountOccurrences<TArray extends readonly unknown[], TType> = FilterNever<[
    ...{
        [K in keyof TArray]: TArray[K] extends TType ? TArray[K] : never;
    }
]>['length'];
/**
 * Removes all occurrences of `never` from {@link TArray}
 *
 * @param TArray - Array to filter
 * @returns Array with `never` removed
 *
 * @example
 * type Result = FilterNever<[1, 2, never, 3, never, 4]>
 */
type FilterNever<TArray extends readonly unknown[]> = TArray['length'] extends 0 ? [] : TArray extends [infer THead, ...infer TRest] ? IsNever<THead> extends true ? FilterNever<TRest> : [THead, ...FilterNever<TRest>] : never;
/**
 * Check if {@link T} is `never`
 *
 * @param T - Type to check
 * @returns `true` if {@link T} is `never`, otherwise `false`
 *
 * @example
 * type Result = IsNever<'foo'>
 */
type IsNever<T> = [T] extends [never] ? true : false;
/**
 * Checks if {@link T} is `unknown`
 *
 * @param T - Type to check
 * @returns `true` if {@link T} is `unknown`, otherwise `false`
 *
 * @example
 * type Result = IsUnknown<unknown>
 */
type IsUnknown<T> = unknown extends T ? true : false;
/**
 * Joins {@link Items} into string separated by {@link Separator}
 *
 * @param Items - Items to join
 * @param Separator - Separator to use
 * @returns Joined string
 *
 * @example
 * type Result = Join<['foo', 'bar'], '-'>
 */
type Join<Items extends string[], Separator extends string | number> = Items extends [infer First, ...infer Rest] ? First extends string ? Rest extends string[] ? Rest extends [] ? `${First}` : `${First}${Separator}${Join<Rest, Separator>}` : never : never : '';
/**
 * Check if {@link T} and {@link U} are equal
 *
 * @param T
 * @param U
 * @returns `true` if {@link T} and {@link U} are not equal, otherwise `false`
 *
 * @example
 * type Result = NotEqual<'foo', 'bar'>
 */
type NotEqual<T, U> = [T] extends [U] ? false : true;
/**
 * Convert {@link TKeys} of {@link TObject} to optional properties
 *
 * @param TObject
 * @param TKeys
 * @returns {@link TObject} with {@link TKeys} converted to optional properties
 *
 * @example
 * type Result = Optional<{ foo: string; bar: number }, 'foo'>
 */
type Optional<TObject, TKeys extends keyof TObject> = {
    [K in keyof TObject as K extends TKeys ? never : K]: TObject[K];
} & {
    [K in keyof TObject as K extends TKeys ? K : never]?: TObject[K];
};
/**
 * Boolean "or" operator
 *
 * @param T
 * @param U
 * @returns `true` if either {@link T} or {@link U} are `true`, otherwise `false`
 *
 * @example
 * type Result = Or<true, false>
 */
type Or<T, U> = T extends true ? true : U extends true ? true : false;
/**
 * Converts {@link Union} to intersection
 *
 * @param Union - Union to convert
 * @returns Intersection of {@link Union}
 *
 * @example
 * type Result = UnionToIntersection<'foo' | 'bar'>
 */
type UnionToIntersection<Union> = (Union extends unknown ? (arg: Union) => unknown : never) extends (arg: infer R) => unknown ? R : never;

type AbiParameter = AbiParameter$1;
/**
 * Configuration options for contract types
 */
type Options = {
    /** Flag for making `abi` optional */
    isAbiOptional?: boolean;
    /** Flag for making `address` optional */
    isAddressOptional?: boolean;
    /** Flag for making `args` optional */
    isArgsOptional?: boolean;
    /** Flag for making `functionName` optional */
    isFunctionNameOptional?: boolean;
};
/**
 * Default {@link Options}
 */
type DefaultOptions = {
    isAbiOptional: false;
    isAddressOptional: false;
    isArgsOptional: false;
    isFunctionNameOptional: false;
};
/**
 * Gets arguments of contract function
 *
 * @param TAbi - Contract {@link Abi}
 * @param TFunctionName - Name of contract function
 * @param TOptions - Options for configuring arguments. Defaults to {@link DefaultOptions}.
 * @returns Inferred args of contract function
 *
 * @example
 * type Result = GetArgs<[…], 'tokenURI'>
 */
type GetArgs<TAbi extends Abi | readonly unknown[], TFunction extends AbiFunction & {
    type: 'function';
}, TOptions extends Options = DefaultOptions> = TFunction['inputs'] extends infer TInputs extends readonly AbiParameter[] ? Or<IsNever<TInputs>, NotEqual<TAbi, Abi>> extends true ? {
    /**
     * Arguments to pass contract method
     *
     * Use a [const assertion](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) on {@link abi} for type inference.
     */
    args?: readonly unknown[];
} : TInputs['length'] extends 0 ? {
    args?: never;
} : AbiParametersToPrimitiveTypes<TInputs> extends infer TArgs ? TOptions['isArgsOptional'] extends true ? {
    /** Arguments to pass contract method */
    args?: TArgs;
} : {
    /** Arguments to pass contract method */
    args: TArgs;
} : never : never;
/**
 * Contract configuration object for inferring function name and arguments based on {@link TAbi}.
 */
type ContractConfig<TContract = {
    [key: string]: unknown;
}, TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = string, TFunction extends AbiFunction & {
    type: 'function';
} = TAbi extends Abi ? ExtractAbiFunction<TAbi, TFunctionName> : never, TOptions extends Options = DefaultOptions> = (TOptions['isAbiOptional'] extends true ? {
    /** Contract ABI */
    abi?: Narrow<TAbi>;
} : {
    /** Contract ABI */
    abi: Narrow<TAbi>;
}) & (TOptions['isAddressOptional'] extends true ? {
    /** Contract address */
    address?: string;
} : {
    /** Contract address */
    address: string;
}) & (TOptions['isFunctionNameOptional'] extends true ? {
    /** Function to invoke on the contract */
    functionName?: IsNever<TFunctionName> extends true ? string : TFunctionName;
} : {
    /** Function to invoke on the contract */
    functionName: IsNever<TFunctionName> extends true ? string : TFunctionName;
}) & GetArgs<TAbi, TFunction, TOptions> & TContract;
type OmitConfigProperties = 'abi' | 'args' | 'functionName';
/**
 * Gets configuration type of contract function
 *
 * @param TContract - Contract config in `{ abi: Abi, functionName: string }` format
 * @param TAbiStateMutibility - State mutability of contract function
 * @param TOptions - Options for configuring arguments. Defaults to {@link DefaultOptions}.
 * @returns Inferred configuration type of contract function
 *
 * @example
 * type Result = GetConfig<{ abi: […], functionName: 'tokenURI' }, 'view'>
 */
type GetConfig<TContract = unknown, TAbiStateMutibility extends AbiStateMutability = AbiStateMutability, TOptions extends Options = DefaultOptions> = TContract extends {
    abi: infer TAbi extends Abi;
    functionName: infer TFunctionName extends string;
} ? ContractConfig<Omit<TContract, OmitConfigProperties>, TAbi, ExtractAbiFunctionNames<TAbi, TAbiStateMutibility>, ExtractAbiFunction<TAbi, TFunctionName>, TOptions> : TContract extends {
    abi: infer TAbi extends readonly unknown[];
    functionName: infer TFunctionName extends string;
} ? ContractConfig<Omit<TContract, OmitConfigProperties>, TAbi, TFunctionName, never, TOptions> : ContractConfig<Omit<TContract, OmitConfigProperties>, Abi, string, never, TOptions>;
/**
 * Unwraps return type of contract function
 *
 * @param TAbi - Contract {@link Abi}
 * @param TFunctionName - Name of contract function
 * @returns Inferred return type of contract function
 *
 * @example
 * type Result = GetResult<[…], 'tokenURI'>
 */
type GetResult<TAbi extends Abi | readonly unknown[] = Abi, TFunctionName extends string = string, TFunction extends AbiFunction & {
    type: 'function';
} = TAbi extends Abi ? ExtractAbiFunction<TAbi, TFunctionName> : never> = TFunction['outputs'] extends infer TOutputs extends readonly AbiParameter[] ? Or<IsNever<TOutputs>, NotEqual<TAbi, Abi>> extends true ? unknown : TOutputs['length'] extends infer TLength ? TLength extends 0 ? void : TLength extends 1 ? AbiParameterToPrimitiveType<TOutputs[0]> : TOutputs extends readonly [...infer _] ? /**
   * Return output as array assigned to an object with named keys
   *
   * | Outputs                                                               | Result                                                     |
   * | --------------------------------------------------------------------- | ---------------------------------------------------------- |
   * | `[{ name: 'foo', type: 'uint256' }, { name: 'bar', type: 'string' }]` | `readonly [bigint, string] & { foo: bigint; bar: string }` |
   * | `[{ name: 'foo', type: 'uint256' }, { name: '', type: 'string' }]`    | `readonly [bigint, string] & { foo: bigint }`              |
   */ {
    [Output in TOutputs[number] as Output extends {
        name: string;
    } ? Output['name'] extends '' ? never : Output['name'] : never]: AbiParameterToPrimitiveType<Output>;
} & AbiParametersToPrimitiveTypes<TOutputs> : unknown : never : never;
/**
 * Gets return type of contract function
 *
 * @param TContract - Contract config in `{ abi: Abi, functionName: string }` format
 * @returns Inferred return type of contract function
 *
 * @example
 * type Result = GetReturnType<{ abi: […], functionName: 'tokenURI' }>
 */
type GetReturnType<TContract = unknown> = TContract extends {
    abi: infer TAbi extends Abi;
    functionName: infer TFunctionName extends string;
} ? GetResult<TAbi, TFunctionName, ExtractAbiFunction<TAbi, TFunctionName>> : TContract extends {
    abi: infer TAbi extends readonly unknown[];
    functionName: infer TFunctionName extends string;
} ? GetResult<TAbi, TFunctionName> : GetResult;
type MAXIMUM_DEPTH = 20;
/**
 * ContractsConfig reducer recursively unwraps function arguments to infer/enforce type param
 *
 * @param TContracts - Array of contracts in shape of {@link ContractConfig}
 * @returns Array of inferred contract configurations
 */
type ContractsConfig<TContracts extends unknown[], TContractProperties extends {
    [key: string]: unknown;
} = {
    [key: string]: unknown;
}, TOptions extends Options = DefaultOptions, Result extends any[] = [], Depth extends ReadonlyArray<number> = []> = Depth['length'] extends MAXIMUM_DEPTH ? GetConfig<TContractProperties, 'pure' | 'view', TOptions>[] : TContracts extends [] ? [] : TContracts extends [infer Head] ? [
    ...Result,
    GetConfig<Head & TContractProperties, 'pure' | 'view', TOptions>
] : TContracts extends [infer Head, ...infer Tail] ? ContractsConfig<[
    ...Tail
], TContractProperties, TOptions, [
    ...Result,
    GetConfig<Head & TContractProperties, 'pure' | 'view', TOptions>
], [
    ...Depth,
    1
]> : unknown[] extends TContracts ? TContracts : TContracts extends ContractConfig<infer TContract, infer TAbi, infer TFunctionName, infer TFunction>[] ? ContractConfig<Omit<TContract & TContractProperties, OmitConfigProperties>, TAbi, TFunctionName, TFunction, TOptions>[] : GetConfig<TContractProperties, 'pure' | 'view', TOptions>[];
/**
 * ContractsResult reducer recursively maps type param to results
 *
 * @param TContracts - Array of contracts in shape of {@link ContractConfig}
 * @returns Array of inferred contract results
 */
type ContractsResult<TContracts extends unknown[], Result extends any[] = [], Depth extends ReadonlyArray<number> = []> = Depth['length'] extends MAXIMUM_DEPTH ? GetReturnType[] : TContracts extends [] ? [] : TContracts extends [infer Head] ? [...Result, GetReturnType<Head>] : TContracts extends [infer Head, ...infer Tail] ? ContractsResult<[...Tail], [...Result, GetReturnType<Head>], [...Depth, 1]> : TContracts extends ContractConfig<infer _TContract, infer TAbi, infer TFunctionName>[] ? GetReturnType<{
    abi: TAbi;
    functionName: TFunctionName;
}>[] : GetReturnType[];
/**
 * Get name for {@link AbiFunction} or {@link AbiEvent}
 *
 * @param TAbiItem - {@link AbiFunction} or {@link AbiEvent}
 * @param IsSignature - Whether to return the signature instead of the name
 * @returns Name or signature of function or event
 *
 * @example
 * type Result = AbiItemName<{ type: 'function'; name: 'Foo'; … }>
 */
type AbiItemName<TAbiItem extends (AbiFunction & {
    type: 'function';
}) | AbiEvent, IsSignature extends boolean = false> = IsSignature extends true ? TAbiItem['inputs'] extends infer TAbiParameters extends readonly AbiParameter[] ? `${TAbiItem['name']}(${Join<[
    ...{
        [K in keyof TAbiParameters]: TAbiParameters[K]['type'];
    }
], ','>})` : never : TAbiItem['name'];
/**
 * Get overrides for {@link AbiStateMutability}
 *
 * @param TAbiStateMutability - {@link AbiStateMutability}
 * @returns Overrides for {@link TAbiStateMutability}
 *
 * @example
 * type Result = GetOverridesForAbiStateMutability<'pure'>
 */
type GetOverridesForAbiStateMutability<TAbiStateMutability extends AbiStateMutability> = {
    nonpayable: Overrides & {
        from?: Address;
    };
    payable: PayableOverrides & {
        from?: Address;
    };
    pure: CallOverrides;
    view: CallOverrides;
}[TAbiStateMutability];
interface Overrides extends ethers.Overrides {
    gasLimit?: ResolvedConfig['BigIntType'];
    gasPrice?: ResolvedConfig['BigIntType'];
    maxFeePerGas?: ResolvedConfig['BigIntType'];
    maxPriorityFeePerGas?: ResolvedConfig['BigIntType'];
    nonce?: ResolvedConfig['IntType'];
}
interface PayableOverrides extends Overrides {
    value?: ResolvedConfig['IntType'] | ResolvedConfig['BigIntType'];
}
interface CallOverrides extends PayableOverrides {
    blockTag?: ethers.CallOverrides['blockTag'];
    from?: Address;
}
type Event<TAbiEvent extends AbiEvent> = Omit<ethers.Event, 'args' | 'event' | 'eventSignature'> & {
    args: AbiParametersToPrimitiveTypes<TAbiEvent['inputs']>;
    event: TAbiEvent['name'];
    eventSignature: AbiItemName<TAbiEvent, true>;
};

export { AbiItemName as A, CountOccurrences as C, DefaultOptions as D, Event as E, GetConfig as G, IsUnknown as I, NotEqual as N, Options as O, UnionToIntersection as U, GetOverridesForAbiStateMutability as a, ContractsConfig as b, ContractsResult as c, GetReturnType as d, Or as e, IsNever as f, AbiParameter as g, ContractConfig as h, GetArgs as i, Optional as j };
